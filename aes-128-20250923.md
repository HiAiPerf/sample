AES-128 encryption/decryption code explanation:

## **Step 1: Generate a Random Key**
```python
key = get_random_bytes(16)  # AES-128 requires 16-byte key
print("Key (base64):", base64.b64encode(key).decode())
```
- **Purpose**: Creates a cryptographically secure random key
- **Details**: 
  - `get_random_bytes(16)` generates 16 random bytes (128 bits)
  - AES-128 uses 128-bit keys (AES-192 uses 192-bit, AES-256 uses 256-bit)
  - The key is encoded in base64 for display/storage

## **Step 2: Create AES Cipher in CBC Mode**
```python
cipher = AES.new(key, AES.MODE_CBC)
iv = cipher.iv
print("IV (base64):", base64.b64encode(iv).decode())
```
- **CBC Mode**: Cipher Block Chaining - each block is XORed with previous ciphertext
- **IV (Initialization Vector)**: 
  - Random 16-byte value generated automatically
  - Ensures same plaintext encrypts to different ciphertext each time
  - Must be unique for each encryption with the same key

## **Step 3: Prepare and Encrypt Plaintext**
```python
plaintext = b"Hello, AES-128 encryption!"
padding_length = 16 - len(plaintext) % 16
plaintext_padded = plaintext + bytes([padding_length]) * padding_length
```
- **Padding**: AES works on 16-byte blocks, so data must be padded
- **PKCS#7 Padding**: Adds bytes where each byte equals the padding length
- **Example**: If message needs 5 padding bytes â†’ adds `\x05\x05\x05\x05\x05`

```python
ciphertext = cipher.encrypt(plaintext_padded)
```
- **Encryption**: Encrypts the padded plaintext using AES-128-CBC
- **Process**: Each 16-byte block is encrypted and chained with the next

## **Step 4: Decryption Process**
```python
decipher = AES.new(key, AES.MODE_CBC, iv)
decrypted_padded = decipher.decrypt(ciphertext)
```
- **Recreate Cipher**: Uses same key and IV for decryption
- **Decrypt**: Reverse the encryption process

```python
padding_length = decrypted_padded[-1]
decrypted = decrypted_padded[:-padding_length]
```
- **Remove Padding**: 
  - Read last byte to determine padding length
  - Remove that many bytes from the end

## **Key Security Points**

1. **IV Management**: IV should be random and transmitted with ciphertext
2. **Padding Oracle Attacks**: CBC with PKCS#7 can be vulnerable to padding oracle attacks
3. **Key Storage**: Never hardcode keys; use secure storage

## **Alternative (More Secure) Approach**
Modern practice often uses authenticated encryption like AES-GCM:
```python
from Crypto.Cipher import AES

cipher = AES.new(key, AES.MODE_GCM)
ciphertext, tag = cipher.encrypt_and_digest(plaintext)
# Provides both confidentiality and authentication
```

This code demonstrates fundamental AES-CBC encryption, which is important to understand but should be used with additional security considerations in production environments.
